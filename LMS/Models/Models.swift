//
//  DataModels.swift
//  SampleLMS
//
//  Created by Madhav Saxena on 18/03/25.
//

import Foundation

// MARK: - Enums
enum issueStatus: String, Codable {
    case issued = "Issue"
    case returned = "Returned"
    case overdue = "Overdue"
    case lost = "Lost"
}

// MARK: - Supabase Models
struct AdminModel: Codable {
    let id: String
    let email: String
    let password: String
    let is_first_login: Bool
    let created_at: String?
}

struct LibrarianModel: Codable {
    let id: String?
    let email: String
    let username: String
    let password: String
    let created_at: String?
    let isFirstLogin: Bool
}

struct LibrarianPasswordUpdate: Codable {
    let password: String
    let isFirstLogin: Bool
}

// MARK: - Email Models
struct EmailData: Encodable {
    let to: String
    let subject: String
    let name: String
    let password: String
}

// MARK: - App Models
struct Admin: Codable, Identifiable {
    let id: String
    let name: String
    let email: String
    let password: String
    let is_first_login: Bool
    let created_at: String?
    
    enum CodingKeys: String, CodingKey {
        case id
        case name
        case email
        case password
        case is_first_login
        case created_at
    }
}

struct Librarian: Codable, Identifiable {
    var id: UUID
    var name: String
    var email: String
    var password: String
    var createdAt: Date
}

struct Member: Codable, Identifiable {
    var id: UUID
    var name: String
    var email: String
    var password: String
    var createdAt: Date
}

struct Book: Codable, Identifiable {
    var id: UUID
    var title: String
    var author: String
    var genre: String?
    var isbn: [String]
    var publicationYear: Int
    var totalCopies: Int
    var availableCopies: Int
}

struct BookIssue: Codable, Identifiable {
    var id: UUID
    var memberID: UUID
    var bookID: UUID
    var issueDate: Date
    var dueDate: Date
    var returnDate: Date?
    var fine: Double = 0.0
    var status: issueStatus
}

// MARK: - Validation Models
struct PasswordValidationResult {
    let isValid: Bool
    let errorMessage: String?
}

struct LibrarianBook: Identifiable, Codable {
    let id: UUID? // Optional because it's generated by Supabase for new books
    let title: String
    let author: [String] // Array of strings for multiple authors
    let genre: String
    let publicationDate: String
    let totalCopies: Int
    let availableCopies: Int
    let ISBN: String
    let Description: String?
    let shelfLocation: String?
    let dateAdded: Date?
    let publisher: String?
    let imageLink: String?
    
    enum CodingKeys: String, CodingKey {
        case id
        case title
        case author
        case genre
        case publicationDate
        case totalCopies
        case availableCopies
        case ISBN
        case Description
        case shelfLocation
        case dateAdded
        case publisher
        case imageLink
    }
    
    init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)
        
        id = try container.decodeIfPresent(UUID.self, forKey: .id)
        title = try container.decode(String.self, forKey: .title)
        author = try container.decode([String].self, forKey: .author)
        genre = try container.decode(String.self, forKey: .genre)
        publicationDate = try container.decode(String.self, forKey: .publicationDate)
        totalCopies = try container.decode(Int.self, forKey: .totalCopies)
        availableCopies = try container.decode(Int.self, forKey: .availableCopies)
        ISBN = try container.decode(String.self, forKey: .ISBN)
        Description = try container.decodeIfPresent(String.self, forKey: .Description)
        shelfLocation = try container.decodeIfPresent(String.self, forKey: .shelfLocation)
        publisher = try container.decodeIfPresent(String.self, forKey: .publisher)
        imageLink = try container.decodeIfPresent(String.self, forKey: .imageLink)
        
        // Handle dateAdded decoding
        if let dateString = try container.decodeIfPresent(String.self, forKey: .dateAdded) {
            let formatter = DateFormatter()
            formatter.dateFormat = "yyyy-MM-dd"
            dateAdded = formatter.date(from: dateString)
        } else {
            dateAdded = nil
        }
    }
    
    init(id: UUID? = nil, 
         title: String = "", 
         author: [String] = [], 
         genre: String = "Uncategorized",
         publicationDate: String = "", 
         totalCopies: Int = 1,
         availableCopies: Int = 1,
         ISBN: String = "",
         Description: String? = nil,
         shelfLocation: String? = nil,
         dateAdded: Date? = Date(),
         publisher: String? = nil,
         imageLink: String? = nil) {
        self.id = id
        self.title = title
        self.author = author
        self.genre = genre
        self.publicationDate = publicationDate
        self.totalCopies = totalCopies
        self.availableCopies = availableCopies
        self.ISBN = ISBN
        self.Description = Description
        self.shelfLocation = shelfLocation
        self.dateAdded = dateAdded
        self.publisher = publisher
        self.imageLink = imageLink
    }
}

// Google Books API response structures
struct GoogleBooksResponse: Codable {
    var items: [VolumeInfo]?
    
    struct VolumeInfo: Codable {
        var volumeInfo: BookInfo
        
        struct BookInfo: Codable {
            var title: String
            var authors: [String]?
            var publisher: String?
            var publishedDate: String?
            var description: String?
            var industryIdentifiers: [IndustryIdentifier]?
            var imageLinks: ImageLinks?
            
            struct IndustryIdentifier: Codable {
                var type: String
                var identifier: String
            }
            
            struct ImageLinks: Codable {
                var thumbnail: String?
            }
        }
    }
}
